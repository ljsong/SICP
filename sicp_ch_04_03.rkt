#lang racket

(define (require p)
  (when (not p) (amb)))

(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))

(define (an-integer-between low high)
  (require (<= low high))
  (amb low (an-integer-between (+ low 1) high)))

(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))

(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
      (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))

(define (multiple-dwelling-refine)
  (let ((cooper (amb 2 3 4 5))
        (miller (amb 3 4 5)))
    (require (> miller cooper))
    (let ((fletcher (amb 2 3 4)))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (let ((smith (amb 1 2 3 4 5)))
        (require (not (= (abs (- smith fletcher)) 1)))
        (let ((baker (amb 1 2 3 4)))
          (require (distinct? (list baker cooper fletcher miller smith)))
          (list (list 'baker baker)
                (list 'cooper cooper)
                (list 'fletcher fletcher)
                (list 'miller miller)
                (list 'smith smith)))))))

(define (multiple-dwelling-normal)
  (define (satisfy item)
    (let ((baker (list-ref item 0))
          (cooper (list-ref item 1))
          (fletcher (list-ref item 2))
          (miller (list-ref item 3))
          (smith (list-ref item 4)))
      (if (and (not (= baker 5))
               (not (= cooper 1))
               (and (not (= fletcher 1)) (not (= fletcher 5)))
               (> miller cooper)
               (not (= (abs (- smith fletcher)) 1))
               (not (= (abs (- fletcher cooper)) 1)))
          #t
          #f)))
  (define (backtrack-solutions candidates)
    (if (not (null? candidates))
        (let ((first (car candidates))
              (remaining (cdr candidates)))
          (if (satisfy first)
              (list (list 'baker (list-ref first 0))
                    (list 'cooper (list-ref first 1))
                    (list 'fletcher (list-ref first 2))
                    (list 'miller (list-ref first 3))
                    (list 'smith (list-ref first 4)))
              (backtrack-solutions remaining)))
        '()))
  (let ((candidates (permutations '(1 2 3 4 5))))
    (backtrack-solutions candidates)))

(multiple-dwelling-normal)

(define (lier)
  (let ((betty (amb 1 2 3 4 5))
        (ethel (amb 1 2 3 4 5))
        (joan (amb 1 2 3 4 5))
        (kitty (amb 1 2 3 4 5))
        (mary (amb 1 2 3 4 5)))
    (require (or (and (= kitty 2) (not (= betty 3)))
                 (and (not (= kitty 2)) (= betty 3))))
    (require (or (and (= ethel 1) (not (= joan 2))))
                 (and (not (= ethel 1)) (= joan 2)))
    (require (or (and (= joan 3) (not (= ethel 5)))
                 (and (not (= joan 3)) (= ethel 5))))
    (require (or (and (= kitty 2) (not (= mary 4)))
                 (and (not (= kitty 2)) (= mary 4))))
    (require (or (and (= mary 4) (not (= betty 1)))
                 (and (not (= mary 4)) (= betty 1))))
    (require (distinct? (list betty ethel joan kitty mary)))
    (list (list 'betty betty)
          (list 'ethel ethel)
          (list 'joan joan)
          (list 'kitty kitty)
          (list 'mary mary))))